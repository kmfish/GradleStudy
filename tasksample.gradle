/**
 * Task的使用例子
 * 参考 https://www.heqiangfly.com/2016/03/13/development-tool-gradle-task/
 */

tasks.create("taskSample1") {
    group = 'Welcome'
    description = 'Produces a greeting'
    doLast {
        println 'taskSample1 Hello, World'
    }
}

task taskSample2 {
    doLast {
        println 'taskSample2 doLast'
    }
}

import com.kmfish.gradle.plugin.MyTask

// 使用自定义的task
task myTaskSample(type: MyTask) {
    doLast {
        println 'myTaskSample doLast'
    }
}

class Greeting extends DefaultTask {
    String message
    String recipient

    @TaskAction
    void sayGreeting() {
        println "${message}, ${recipient}!"
    }
}

tasks.create("myself", Greeting) {
    group = 'Welcome'
    description = 'Produces a German greeting'
    message = 'myself'
    recipient = 'hello'
}
tasks.create("gutenTag", Greeting) {
    group = 'Welcome'
    description = 'Produces a German greeting'
    message = 'Guten Tag'
    recipient = 'Welt'
}

//动态任务
4.times { counter ->
    task "task$counter" {
        doLast {
            println "I'm task number $counter"
        }
    }
}

//在Task中调用其他Task
task A {
    doLast {
        C.execute()
    }
}
task C {
    doLast {
        println 'Hello from C'
    }
}

//// 将自定义任务挂接到assemble任务的最后再执行
afterEvaluate { Project project ->
    def t = project.tasks.findByName("assemble")
    if (t == null) {
        project.subprojects { pro ->
            t = pro.tasks.findByName("assemble")
            return
        }
    }

    println 'found task: assemble'
    if (t != null) {
        t.doLast {
            def testTask = project.tasks.findByName("C")
            testTask.execute()
        }
    }
}

task AA {
    doLast {
        println 'hello from AA'
    }
}

// 任务依赖
task BB(dependsOn: AA) {
    doLast {
        println 'hello from BB'
    }
}
task BBB {
    doLast {
        println 'hello from BBB'
    }
}
BBB.dependsOn AA

task BBBB {
    dependsOn AA
    doLast {
        println 'hello from BBBB'
    }
}

// 插入依赖在已经存在的task中
task B1 {
    doLast {
        println 'hello from B1'
    }
}

B1.dependsOn AA
BBBB.dependsOn BB


// 任务排序

//mustRunAfter 与 shouldRunAfter
//在某些情况下，我们希望能控制任务的的执行顺序，这种控制并不是向上面那样去显示地加入依赖关系。

task A2 {
    doLast {
        println 'Hello from A2'
    }
}
task B2 {
    doLast {
        println 'Hello from B2'
    }
}
A2.mustRunAfter B2
// ./gradlew -q A2 B2
// 输出：
// Hello from B2
// Hello from A2
// 虽然我们将两个任务进行了排序，但是他们仍然是可以单独执行的，任务排序不影响任务执行。排序规则只有当两个任务同时执行时才会被应用。
// ./gradlew -q A2
// 输出：
// Hello from A2

//另外，shouldRunAfter 不影响任务之间的执行依赖。但如果 mustRunAfter 和任务依赖之间发生了冲突，那么执行时将会报错。


// finalizedBy
// 执行完任务 A 之后必须要执行一下任务 B
task A3 {
    doLast {
        println 'Hello from A3'
    }
}
task B3 {
    doLast {
        println 'Hello from B3'
    }
}
A3.finalizedBy B3


// Task Type
//Gradle 本身还提供了一些已有的 task 供我们使用，比如 Copy、Delete、Sync 等。
// 因此我们定义 task 的时候是可以继承已有的 task，比如我们可以继承自系统的 Copy Task 来完成文件的拷贝操作。

// Copy (见 app/build.gradle 例子）
//task helloCopy (type: Copy){
//    from 'src/main/AndroidManifest.xml'  // 调用 from 方法
//    into 'build/test'  // 调用 into 方法
//    // 调用 rename 方法
//    rename {String fileName ->
//        fileName = "AndroidManifestCopy.xml"
//    }
//}

// Exec Task 用来执行命令行
task pwdTask(type: Exec) {
    //    workingDir '..'
    commandLine 'pwd'
    //store the output instead of printing to the console:
    standardOutput = new ByteArrayOutputStream()

    //extension method stopTomcat.output() can be used to obtain the output:
    ext.output = {
        return standardOutput.toString()
    }
}

task printPwdResult(dependsOn: pwdTask) {
    doLast {
        println 'pwd result:' + pwdTask.output()
    }
}


// 任务的执行 条件
// 判断条件 onlyIf()，用一个闭包来返回判断条件，当task 执行时非配置期调用该闭包。
// 执行 “./gradlew A -PskipA”，就不会再执行
task skipA1 {
    doLast {
        println 'hello from skipA'
    }
}

skipA1.onlyIf { !project.hasProperty('skipA') }


// 使用 StopExecutionException
//如果想要跳过一个任务的逻辑并不能被判断条件通过表达式表达出来，那么可以使用 StopExecutionException。
// 如果这个异常是被一个任务要执行的动作抛出的，这个动作之后的执行以及所有紧跟它的动作都会被跳过。
// 构建将会继续执行下一个任务。
// 如果你直接使用 Gradle 提供的任务，这项功能还是十分有用的。它允许你为内建的任务加入条件来控制执行。
task skipA2 {
    doFirst {
        println 'task skipA2 doFirst'
        throw new StopExecutionException()
    }
    doLast {
        println 'task skipA2 doLast'
    }
}




















